Некоторые утверждения, которые встречаются во многих источниках по теме TDD.
Процесс разработки начинается с написания теста. Тест влияет на код (заведомо неправильный подход).

Предположим, что я хочу реализовать структуру данных, например, стек. Решил повторить один из курсов АСД.
Я знаю, что стек это такая структура данных, которая работает по принципу "последний вошёл - первый вышел". Должны быть методы pop и push.
Возможно нужна будет пара вспомогательных методов. Но сначала тест!

```java
@Test
void createNewStack() {
    Stack stack = new Stack();

    assertTrue(stack.isEmpty());
}
```
Чтобы тест прошел нужно создать класс с именем Stack и написать в нем метод isEmpty(), который просто вернет true. Тест будет пройден.
Далее я могу добавлять тесты на push и pop, реализовывать методы в классе, хардкодя результат и тесты будут проходить.
Такой итеративный подход соответствует идее TDD. Однако, при разработке Stack, спустя 3-5 итераций,
я имею класс с какими-то хардкодными методами, которые удовлетворяют тестам. Но весь мой код все еще не удовлетворяет идее стека. Еще даже не появился динамический массив (или обычный) для хранения элементов.

И все же в таком подходе можно постепенно приближаться к реализации идеи стека, придумывая все новые и новые тесты, которые будут "утверждать", что при каких-то условиях код не работает корректно.

Недостатки подхода:
- тест пишется на каждый метод, что совсем не обязательно, т.к не гарантирует корректность работы кода
- класс, для которого пишутся тесты, может содержать зависимости (их нужно мокать). В случае, когда тесты и код зависят/следуют друг другу, малейшее изменение в паре классов/методов с высокой вероятностью приводят к тому, что множество тестов сломается. 
- тратится много времени впустую, большинство тестов очень хрупки и их постоянно нужно переписывать. То есть еще и правила TDD таким образом в итоге нарушаются.

Поэтому лучше начать с соблюдения правил:
1. Код не должен следовать тестам, ни тесты не должны следовать коду.
2. И тесты, и код должны следовать дизайну, логической архитектуре.

Получается, что сначала нужен дизайн, за которым последует и тесты, и код.
Нужно сначала продумать АТД Stack.

Нужна команда. Для упрощения только одна
// постусловие: из стека удалятся все значения
public void clear();

Предположим, что будет реализация стека на основе динамического массива. Это тоже своего рода спецификация.

Теперь пишу тест, следуя дизайну
```java
@Test
void createNewStack() {
    Stack stack = new DynArrayStack();

    stack.clear()

    assertTrue(stack.innerDynArray.isEmpty());
}
```

код под тест
```java
class DynArrayStack<T> {
    private ArrayList<T> arr;
    void clear() {
        arr.removeAll();
    }
}
```

Теперь, если я решу как-то иначе очищать стек и изменю детали реализации, то это никак не повлияет на тест. Если и код и тест соответствуют спецификации, то все ок.

Выводы:
- начинать нужно с проработки спецификаций
- во вторую очередь нужно думать о тестах, чтобы уточнить спецификации, исправить недочеты
- и только затем писать код реализации
